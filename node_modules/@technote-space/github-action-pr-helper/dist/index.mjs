import { getInput, setOutput, setFailed } from '@actions/core';
import { Context } from '@actions/github/lib/context';
import { Utils, ContextHelper, ApiHelper, GitHelper } from '@technote-space/github-action-helper';
import { Logger } from '@technote-space/github-action-log-helper';
import { isTargetEvent, isTargetLabels } from '@technote-space/filter-github-action';
import moment from 'moment';

const DEFAULT_TRIGGER_WORKFLOW_MESSAGE = 'chore: trigger workflow';
const DEFAULT_TARGET_EVENTS = {
    'pull_request': [
        'opened',
        'reopened',
        'synchronize',
        'labeled',
        'unlabeled',
        'closed',
    ],
    'schedule': '*',
    'repository_dispatch': '*',
    'workflow_dispatch': '*',
    'workflow_run': '*',
};
const INTERVAL_MS = 1000;

const { getBranch: getBranch$2 } = Utils;
const { isPush: isPush$3 } = ContextHelper;
const getCommitMessage = (context) => getActionDetail('commitMessage', context);
const getCommitName = (context) => getActionDetail('commitName', context, () => context.actionContext.actor);
const getCommitEmail = (context) => getActionDetail('commitEmail', context, () => `${context.actionContext.actor}@users.noreply.github.com`);
const getVariable = (index, context) => getActionDetail('prVariables', context)[index];
const getPrLink = (context) => context.actionContext.payload.pull_request ? `[${context.actionContext.payload.pull_request.title}](${context.actionContext.payload.pull_request.html_url})` : '';
const getDate = (index, context) => moment().format(getActionDetail('prDateFormats', context)[index]);
const contextVariables = async (isComment, octokit, context) => {
    const getContext = async (branch) => {
        if (isComment) {
            if (branch === await getDefaultBranch(octokit, context)) {
                return getActionContext$1(await getPullsArgsForDefaultBranch(octokit, context), octokit, context);
            }
            return getActionContext$1(await findPR(branch, octokit, context), octokit, context);
        }
        return context;
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const getPrParamFunc = (extractor) => async () => {
        if (!context.actionContext.payload.pull_request) {
            throw new Error('Invalid context.');
        }
        return extractor(await ensureGetPulls((await getContext(getContextBranch(context))).actionContext.payload.pull_request, octokit, context));
    };
    return [
        { key: 'PR_NUMBER', replace: getPrParamFunc(pr => pr.number) },
        { key: 'PR_NUMBER_REF', replace: getPrParamFunc(async (pr) => pr.number ? `#${pr.number}` : await getDefaultBranchUrl(octokit, context)) },
        { key: 'PR_ID', replace: getPrParamFunc(pr => pr.id) },
        { key: 'PR_HEAD_REF', replace: getPrParamFunc(pr => pr.head.ref) },
        { key: 'PR_BASE_REF', replace: getPrParamFunc(pr => pr.base.ref) },
        { key: 'PR_TITLE', replace: getPrParamFunc(pr => pr.title) },
        { key: 'PR_URL', replace: getPrParamFunc(pr => pr.html_url) },
        { key: 'PR_MERGE_REF', replace: getPrParamFunc(async (pr) => pr.number ? `${pr.head.ref} -> ${pr.base.ref}` : await getDefaultBranch(octokit, context)) },
        { key: 'PR_LINK', replace: async () => getPrLink(context) },
        { key: 'CURRENT_VERSION', replace: async () => getCurrentVersion(octokit, context) },
        { key: 'PATCH_VERSION', replace: async () => getNewPatchVersion(octokit, context) },
        { key: 'MINOR_VERSION', replace: async () => getNewMinorVersion(octokit, context) },
        { key: 'MAJOR_VERSION', replace: async () => getNewMajorVersion(octokit, context) },
        // eslint-disable-next-line no-magic-numbers
    ].concat([...Array(context.actionDetail.prVariables?.length ?? 0).keys()].map(index => ({
        // eslint-disable-next-line no-magic-numbers
        key: `VARIABLE${index + 1}`, replace: async () => getVariable(index, context),
        // eslint-disable-next-line no-magic-numbers
    }))).concat([...Array(context.actionDetail.prDateFormats?.length ?? 0).keys()].map(index => ({
        // eslint-disable-next-line no-magic-numbers
        key: `DATE${index + 1}`, replace: async () => getDate(index, context),
    })));
};
const replaceContextVariables = async (string, octokit, context) => Utils.replaceVariables(string, await contextVariables(false, octokit, context));
const getPrBranchName = async (octokit, context, isDuplicateCheck = false) => {
    if (isPush$3(context.actionContext)) {
        return getBranch$2(context.actionContext);
    }
    if (isActionPr(context) || isNotCreatePR(context)) {
        return getPrHeadRef(context);
    }
    let prefix;
    let branch;
    if (await isDefaultBranch(octokit, context)) {
        prefix = getPrBranchPrefixForDefaultBranch(context);
    }
    else {
        prefix = getPrBranchPrefix(context);
    }
    try {
        if (await isDefaultBranch(octokit, context)) {
            branch = getActionDetail('prBranchNameForDefaultBranch', context, () => getActionDetail('prBranchName', context));
        }
        else {
            branch = getActionDetail('prBranchName', context);
        }
    }
    catch (error) {
        if (isDuplicateCheck && (error instanceof ParameterRequiredError)) {
            return `${context.actionContext.runNumber}`;
        }
        throw error;
    }
    return prefix + await replaceContextVariables(branch, octokit, context);
};
const getPrTitle = async (octokit, context) => await replaceContextVariables((await isDefaultBranch(octokit, context) ?
    getActionDetail('prTitleForDefaultBranch', context, () => getActionDetail('prTitle', context)) :
    getActionDetail('prTitle', context)).trim(), octokit, context);
const prBodyVariables = async (isComment, files, output, octokit, context) => {
    const toCode = (string) => string.length ? ['', '```Shell', string, '```', ''].join('\n') : '';
    return [
        {
            key: 'COMMANDS',
            replace: async () => output.length ? toCode(output.map(item => `$ ${item.command}`).join('\n')) : '',
        },
        {
            key: 'COMMANDS_STDOUT',
            replace: async () => output.length ? '<details>\n' + output.map(item => [
                `<summary><em>${item.command}</em></summary>`,
                toCode(item.stdout.join('\n')),
            ].join('\n')).join('\n</details>\n<details>\n') + '\n</details>' : '',
        },
        {
            key: 'COMMANDS_OUTPUT',
            replace: async () => output.length ? '<details>\n' + output.map(item => [
                `<summary><em>${item.command}</em></summary>`,
                toCode(item.stdout.join('\n')),
                item.stderr.length ? '### stderr:' : '',
                toCode(item.stderr.join('\n')),
            ].join('\n')).join('\n</details>\n<details>\n') + '\n</details>' : '',
        },
        {
            key: 'COMMANDS_STDOUT_OPENED',
            replace: async () => output.length ? '<details open>\n' + output.map(item => [
                `<summary><em>${item.command}</em></summary>`,
                toCode(item.stdout.join('\n')),
            ].join('\n')).join('\n</details>\n<details open>\n') + '\n</details>' : '',
        },
        {
            key: 'COMMANDS_STDERR',
            replace: async () => output.length ? '<details>\n' + output.map(item => [
                `<summary><em>${item.command}</em></summary>`,
                toCode(item.stderr.join('\n')),
            ].join('\n')).join('\n</details>\n<details>\n') + '\n</details>' : '',
        },
        {
            key: 'COMMANDS_STDERR_OPENED',
            replace: async () => output.length ? '<details open>\n' + output.map(item => [
                `<summary><em>${item.command}</em></summary>`,
                toCode(item.stderr.join('\n')),
            ].join('\n')).join('\n</details>\n<details open>\n') + '\n</details>' : '',
        },
        {
            key: 'FILES',
            replace: async () => files.map(file => `- ${file}`).join('\n'),
        },
        {
            key: 'FILES_SUMMARY',
            // eslint-disable-next-line no-magic-numbers
            replace: async () => 'Changed ' + (files.length > 1 ? `${files.length} files` : 'file'),
        },
        {
            key: 'ACTION_NAME',
            replace: async () => context.actionDetail.actionName,
        },
        {
            key: 'ACTION_OWNER',
            replace: async () => context.actionDetail.actionOwner,
        },
        {
            key: 'ACTION_REPO',
            replace: async () => context.actionDetail.actionRepo,
        },
        {
            key: 'ACTION_URL',
            replace: async () => `https://github.com/${context.actionDetail.actionOwner}/${context.actionDetail.actionRepo}`,
        },
        {
            key: 'ACTION_MARKETPLACE_URL',
            replace: async () => `https://github.com/marketplace/actions/${context.actionDetail.actionRepo}`,
        },
    ].concat(await contextVariables(isComment, octokit, context));
};
const replacePrBodyVariables = async (isComment, prBody, files, output, octokit, context) => Utils.replaceVariables(prBody, await prBodyVariables(isComment, files, output, octokit, context));
const getPrBody = async (isComment, files, output, octokit, context) => replacePrBodyVariables(isComment, (isComment ?
    getActionDetail('prBodyForComment', context, () => getActionDetail('prBody', context)) :
    (await isDefaultBranch(octokit, context) ?
        getActionDetail('prBodyForDefaultBranch', context, () => getActionDetail('prBody', context)) :
        getActionDetail('prBody', context))).trim().split(/\r?\n/).map(line => line.replace(/^[\s\t]+/, '')).join('\n'), files, output, octokit, context);

const { getWorkspace: getWorkspace$1, getLocalRefspec, getRefspec } = Utils;
const { getOctokit, ensureNotNullValue, useNpm } = Utils;
const { getRepository, isPush: isPush$2 } = ContextHelper;
const getApiHelper = (octokit, context, logger) => new ApiHelper(octokit, context.actionContext, logger);
const userConfig = async (helper, context) => await helper.config(getWorkspace$1(), {
    name: getCommitName(context),
    email: getCommitEmail(context),
});
const branchConfig = async (helper, octokit, context) => await helper.config(getWorkspace$1(), {
    defaultBranch: await getDefaultBranch(octokit, context),
});
const clone = async (helper, logger, octokit, context) => {
    const branchName = await getPrBranchName(octokit, context);
    logger.startProcess('Fetching...');
    helper.useOrigin(true);
    await helper.fetchOrigin(getWorkspace$1(), context.actionContext, ['--no-tags'], [getRefspec(branchName)]);
    await helper.runCommand(getWorkspace$1(), {
        command: 'git reset',
        args: ['--hard'],
        suppressError: true,
    });
    logger.startProcess('Switching branch to [%s]...', branchName);
    await helper.switchBranch(getWorkspace$1(), branchName);
};
const checkBranch = async (helper, logger, octokit, context) => {
    const clonedBranch = await helper.getCurrentBranchName(getWorkspace$1());
    const branchName = await getPrBranchName(octokit, context);
    if (branchName === clonedBranch) {
        await helper.runCommand(getWorkspace$1(), {
            command: 'git merge',
            args: ['--no-edit', getLocalRefspec(branchName)],
        });
        await helper.runCommand(getWorkspace$1(), 'ls -la');
        return !isPush$2(context.actionContext);
    }
    if (isPush$2(context.actionContext)) {
        throw new Error(`remote branch [${branchName}] not found.`);
    }
    logger.info('remote branch [%s] not found.', branchName);
    logger.info('now branch: %s', clonedBranch);
    const headRef = getPrHeadRef(context);
    logger.startProcess('Cloning [%s] from the remote repo...', headRef);
    await helper.fetchOrigin(getWorkspace$1(), context.actionContext, ['--no-tags'], [getRefspec(headRef)]);
    await helper.switchBranch(getWorkspace$1(), headRef);
    await helper.createBranch(getWorkspace$1(), branchName);
    await helper.runCommand(getWorkspace$1(), 'ls -la');
    return false;
};
const getClearPackageCommands = (context) => {
    if (isDisabledDeletePackage(context)) {
        return [];
    }
    return [
        'rm -f package.json',
        'rm -f package-lock.json',
        'rm -f yarn.lock',
    ];
};
const getGlobalInstallPackagesCommands = (context) => {
    const packages = getActionDetail('globalInstallPackages', context, () => []);
    if (packages.length) {
        if (useNpm(getWorkspace$1(), getInput('PACKAGE_MANAGER'))) {
            return [
                'sudo npm install -g ' + packages.join(' '),
            ];
        }
        else {
            return [
                'sudo yarn global add ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const getDevInstallPackagesCommands = (context) => {
    const packages = getActionDetail('devInstallPackages', context, () => []);
    if (packages.length) {
        if (useNpm(getWorkspace$1(), getInput('PACKAGE_MANAGER'))) {
            return [
                'npm install --save-dev ' + packages.join(' '),
            ];
        }
        else {
            return [
                'yarn add --dev ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const getInstallPackagesCommands = (context) => {
    const packages = getActionDetail('installPackages', context, () => []);
    if (packages.length) {
        if (useNpm(getWorkspace$1(), getInput('PACKAGE_MANAGER'))) {
            return [
                'npm install --save ' + packages.join(' '),
            ];
        }
        else {
            return [
                'yarn add ' + packages.join(' '),
            ];
        }
    }
    return [];
};
const getExecuteCommands = (context) => getActionDetail('executeCommands', context, () => []);
const getDiff = async (helper, logger) => {
    logger.startProcess('Checking diff...');
    await helper.runCommand(getWorkspace$1(), 'git add --all');
    return await helper.getDiff(getWorkspace$1());
};
const getRefDiff = async (compare, helper, logger, context) => {
    logger.startProcess('Checking references diff...');
    await helper.fetchBranch(getWorkspace$1(), compare, context.actionContext);
    return (await helper.getRefDiff(getWorkspace$1(), 'HEAD', compare, getGitFilterStatus(context), '..'));
};
const initDirectory = async (helper, logger) => {
    logger.startProcess('Initializing working directory...');
    helper.useOrigin(true);
    await helper.runCommand(getWorkspace$1(), { command: 'rm', args: ['-rdf', getWorkspace$1()] });
};
const merge = async (branch, helper, logger, context) => {
    logger.startProcess('Merging [%s] branch...', getLocalRefspec(branch));
    await helper.fetchOrigin(getWorkspace$1(), context.actionContext, ['--no-tags'], [getRefspec(branch)]);
    await userConfig(helper, context);
    const results = await helper.runCommand(getWorkspace$1(), {
        command: 'git merge',
        args: ['--no-edit', getLocalRefspec(branch)],
        suppressError: true,
    });
    return !results[0].stdout.some(RegExp.prototype.test, /^CONFLICT /);
};
const abortMerge = async (helper, logger) => {
    logger.startProcess('Aborting merge...');
    await helper.runCommand(getWorkspace$1(), 'git merge --abort');
};
const commit = async (helper, logger, context) => {
    await userConfig(helper, context);
    logger.startProcess('Committing...');
    await helper.makeCommit(getWorkspace$1(), getCommitMessage(context));
};
const push = async (branchName, helper, logger, context) => {
    logger.startProcess('Pushing to %s@%s...', getRepository(context.actionContext), branchName);
    await helper.push(getWorkspace$1(), branchName, context.actionContext);
};
const forcePush = async (branchName, helper, logger, context) => {
    logger.startProcess('Pushing to %s@%s...', getRepository(context.actionContext), branchName);
    await helper.forcePush(getWorkspace$1(), branchName, context.actionContext);
};
const isMergeable = async (number, octokit, context) => getCache(getCacheKey('pulls.get', {
    owner: context.actionContext.repo.owner,
    repo: context.actionContext.repo.repo,
    'pull_number': number,
}), async () => ensureNotNullValue((await octokit.rest.pulls.get({
    owner: context.actionContext.repo.owner,
    repo: context.actionContext.repo.repo,
    'pull_number': number,
})).data.mergeable, false), context);
const afterCreatePr = async (branchName, number, helper, logger, octokit, context) => {
    if (context.actionDetail.labels?.length) {
        logger.info('Adding labels...');
        console.log(context.actionDetail.labels);
        await octokit.rest.issues.addLabels({
            ...context.actionContext.repo,
            'issue_number': number,
            labels: context.actionDetail.labels,
        });
    }
    if (context.actionDetail.assignees?.length) {
        logger.info('Adding assignees...');
        console.log(context.actionDetail.assignees);
        await octokit.rest.issues.addAssignees({
            ...context.actionContext.repo,
            'issue_number': number,
            assignees: context.actionDetail.assignees,
        });
    }
    if (context.actionDetail.reviewers?.length || context.actionDetail.teamReviewers?.length) {
        logger.info('Adding reviewers...');
        console.log(context.actionDetail.reviewers);
        console.log(context.actionDetail.teamReviewers);
        await octokit.rest.pulls.requestReviewers({
            ...context.actionContext.repo,
            'pull_number': number,
            reviewers: context.actionDetail.reviewers,
            'team_reviewers': context.actionDetail.teamReviewers,
        });
    }
    if (isActiveTriggerWorkflow(context)) {
        // add empty commit to trigger pr event
        await helper.runCommand(getWorkspace$1(), {
            command: 'git commit',
            args: [
                '--allow-empty',
                '-qm',
                getTriggerWorkflowMessage(context),
            ],
        });
        await push(branchName, helper, logger, context);
    }
};
const updatePr = async (branchName, files, output, helper, logger, octokit, context) => {
    const apiHelper = getApiHelper(getOctokit(getApiToken()), context, logger);
    const pr = await apiHelper.findPullRequest(branchName);
    if (pr) {
        logger.startProcess('Creating comment to PullRequest...');
        await apiHelper.createCommentToPr(branchName, await getPrBody(true, files, output, octokit, context));
        return isMergeable(pr.number, octokit, context);
    }
    logger.startProcess('Creating PullRequest...');
    const { number } = await apiHelper.pullsCreate(branchName, {
        title: await getPrTitle(octokit, context),
        body: await getPrBody(false, files, output, octokit, context),
    });
    await afterCreatePr(branchName, number, helper, logger, octokit, context);
    return true;
};
const runCommand = async (command, helper, logger, context) => {
    if ('string' === typeof command) {
        return (await helper.runCommand(getWorkspace$1(), command))[0];
    }
    const result = await command(context, helper, logger);
    logger.displayCommand(result.command);
    if (result.stdout.length) {
        logger.displayStdout(result.stdout);
    }
    if (result.stderr.length) {
        logger.displayStderr(result.stderr);
    }
    return result;
};
const runCommands = async (helper, logger, context) => {
    const commands = [].concat.apply([], [
        getClearPackageCommands(context),
        getGlobalInstallPackagesCommands(context),
        getDevInstallPackagesCommands(context),
        getInstallPackagesCommands(context),
        getExecuteCommands(context),
    ]);
    logger.startProcess('Running commands...');
    const output = await commands.reduce(async (prev, command) => {
        const acc = await prev;
        return acc.concat(await runCommand(command, helper, logger, context));
    }, Promise.resolve([]));
    return {
        files: await getDiff(helper, logger),
        output,
    };
};
const getChangedFiles = async (helper, logger, octokit, context) => {
    await clone(helper, logger, octokit, context);
    if (await checkBranch(helper, logger, octokit, context)) {
        if (!await merge(getContextBranch(context), helper, logger, context)) {
            await abortMerge(helper, logger);
            return { files: [], output: [], aborted: true };
        }
    }
    return runCommands(helper, logger, context);
};
const getChangedFilesForRebase = async (helper, logger, octokit, context) => {
    await initDirectory(helper, logger);
    const branchName = getContextBranch(context);
    await helper.fetchOrigin(getWorkspace$1(), context.actionContext, ['--no-tags'], [getRefspec(branchName)]);
    await helper.switchBranch(getWorkspace$1(), branchName);
    await helper.createBranch(getWorkspace$1(), await getPrBranchName(octokit, context));
    return runCommands(helper, logger, context);
};
const closePR = async (branchName, logger, context, message) => getApiHelper(getOctokit(getApiToken()), context, logger).closePR(branchName, message ?? context.actionDetail.prCloseMessage);
const resolveConflicts = async (branchName, helper, logger, octokit, context) => {
    if (await merge(getContextBranch(context), helper, logger, context)) {
        // succeeded to merge
        await push(branchName, helper, logger, context);
    }
    else {
        // failed to merge
        const { files, output } = await getChangedFilesForRebase(helper, logger, octokit, context);
        if (!files.length) {
            await closePR(branchName, logger, context);
            return 'has been closed because there is no diff';
        }
        await commit(helper, logger, context);
        await forcePush(branchName, helper, logger, context);
        await getApiHelper(getOctokit(getApiToken()), context, logger).pullsCreateOrUpdate(branchName, {
            title: await getPrTitle(octokit, context),
            body: await getPrBody(false, files, output, octokit, context),
        });
    }
    return 'updated';
};
const getDefaultBranch = async (octokit, context) => getCache(getCacheKey('repos', {
    owner: context.actionContext.repo.owner,
    repo: context.actionContext.repo.repo,
}), () => getApiHelper(octokit, context).getDefaultBranch(), context);
const getCurrentVersion = async (octokit, context) => getCache(getCacheKey('current-version'), () => getApiHelper(octokit, context).getLastTag(), context);
const getNewPatchVersion = async (octokit, context) => getCache(getCacheKey('new-patch-version'), () => getApiHelper(octokit, context).getNewPatchVersion(), context);
const getNewMinorVersion = async (octokit, context) => getCache(getCacheKey('new-minor-version'), () => getApiHelper(octokit, context).getNewMinorVersion(), context);
const getNewMajorVersion = async (octokit, context) => getCache(getCacheKey('new-major-version'), () => getApiHelper(octokit, context).getNewMajorVersion(), context);
const findPR = async (branchName, octokit, context) => getCache(getCacheKey('pr', { branchName }), () => getApiHelper(octokit, context).findPullRequest(branchName), context);

const { getWorkspace, getPrefixRegExp, getAccessToken } = Utils;
const { escapeRegExp, replaceAll, getBranch: getBranch$1 } = Utils;
const { isPr: isPr$1, isCron, isPush: isPush$1, isCustomEvent, isManualEvent, isWorkflowRun } = ContextHelper;
class ParameterRequiredError extends Error {
    constructor(target) {
        super(`parameter [${target}] is required.`);
        Object.setPrototypeOf(this, ParameterRequiredError.prototype);
    }
}
const getActionDetail = (key, context, defaultValue) => {
    if (undefined === defaultValue && !(key in context.actionDetail)) {
        throw new ParameterRequiredError(key);
    }
    if (undefined === defaultValue && typeof context.actionDetail[key] === 'string' && context.actionDetail[key].trim() === '') {
        throw new ParameterRequiredError(key);
    }
    return context.actionDetail[key] || (typeof defaultValue === 'function' ? defaultValue() : undefined);
};
const toArray = (item) => Array.isArray(item) ? item : [item];
const replaceDirectory = (message) => {
    const workDir = getWorkspace();
    return replaceAll(replaceAll(message, ` -C ${workDir}`, ''), workDir, '[Working Directory]');
};
const getDefaultBranchUrl = async (octokit, context) => `https://github.com/${context.actionContext.repo.owner}/${context.actionContext.repo.repo}/tree/${await getDefaultBranch(octokit, context)}`;
const getPrHeadRef = (context) => context.actionContext.payload.pull_request?.head.ref ?? '';
const getPrBaseRef = (context) => context.actionContext.payload.pull_request?.base.ref ?? '';
const getPrBranchPrefix = (context) => context.actionDetail.prBranchPrefix || `${context.actionDetail.actionRepo}/`;
const getPrBranchPrefixForDefaultBranch = (context) => context.actionDetail.prBranchPrefixForDefaultBranch || getPrBranchPrefix(context);
const isActionPr = (context) => getPrefixRegExp(getPrBranchPrefix(context)).test(getPrHeadRef(context)) || getPrefixRegExp(getPrBranchPrefixForDefaultBranch(context)).test(getPrHeadRef(context));
const getContextBranch = (context) => context.isBatchProcess ? getPrBaseRef(context) : (getBranch$1(context.actionContext) || getPrHeadRef(context));
const isDefaultBranch = async (octokit, context) => await getDefaultBranch(octokit, context) === getContextBranch(context);
const checkDefaultBranch = (context) => context.actionDetail.checkDefaultBranch ?? true;
const checkOnlyDefaultBranch = (context) => context.actionDetail.checkOnlyDefaultBranch ?? false;
const isDisabledDeletePackage = (context) => !(context.actionDetail.deletePackage ?? false);
const isClosePR = (context) => isPr$1(context.actionContext) && context.actionContext.payload.action === 'closed';
const isNotCreatePR = (context) => true === context.actionDetail.notCreatePr;
const isTargetBranch = async (branchName, octokit, context) => {
    if (branchName === await getDefaultBranch(octokit, context)) {
        return checkDefaultBranch(context);
    }
    const prefix = toArray(getActionDetail('targetBranchPrefix', context, () => []));
    if (prefix.length) {
        return prefix.some(prefix => getPrefixRegExp(prefix).test(branchName));
    }
    return !checkOnlyDefaultBranch(context);
};
const isTargetContext = async (octokit, context) => {
    if (!isTargetEvent(context.actionDetail.targetEvents ?? DEFAULT_TARGET_EVENTS, context.actionContext)) {
        return false;
    }
    if (isCron(context.actionContext) || isCustomEvent(context.actionContext) || isManualEvent(context.actionContext) || isWorkflowRun(context.actionContext)) {
        return true;
    }
    if (isPush$1(context.actionContext)) {
        return isTargetBranch(getBranch$1(context.actionContext), octokit, context);
    }
    if (isActionPr(context)) {
        return true;
    }
    if (isClosePR(context)) {
        return true;
    }
    if (!await isTargetBranch(getPrHeadRef(context), octokit, context)) {
        return false;
    }
    return isTargetLabels(toArray(getActionDetail('includeLabels', context, () => [])), [], context.actionContext);
};
const getGitFilterStatus = (context) => context.actionDetail.filterGitStatus;
const filterGitStatus = (line, context) => {
    const filter = getGitFilterStatus(context);
    if (filter) {
        const targets = filter.toUpperCase().replace(/[^MDA]/g, '');
        if (!targets) {
            throw new Error('Invalid input [FILTER_GIT_STATUS].');
        }
        // language=JSRegexp
        return (new RegExp(`^[${targets}]\\s+`)).test(line);
    }
    return true;
};
const filterExtension = (line, context) => {
    const extensions = toArray(getActionDetail('filterExtensions', context, () => []));
    if (extensions.length) {
        const pattern = '(' + extensions.map(item => escapeRegExp('.' + item.replace(/^\./, ''))).join('|') + ')';
        return (new RegExp(`${pattern}$`)).test(line);
    }
    return true;
};
const getHelper = (context) => new GitHelper(new Logger(replaceDirectory), {
    depth: -1,
    filter: (line) => filterGitStatus(line, context) && filterExtension(line, context),
});
const getPullsArgsForDefaultBranch = async (octokit, context) => ({
    number: 0,
    id: 0,
    head: {
        ref: await getDefaultBranch(octokit, context),
        user: {
            login: context.actionContext.repo.owner,
        },
    },
    base: {
        repo: {
            name: context.actionContext.repo.repo,
            owner: {
                login: context.actionContext.repo.owner,
            },
        },
        ref: await getDefaultBranch(octokit, context),
    },
    title: 'default branch',
    'html_url': await getDefaultBranchUrl(octokit, context),
});
const ensureGetPulls = async (pull, octokit, context) => pull ?? await getPullsArgsForDefaultBranch(octokit, context);
const getActionContext$1 = async (pull, octokit, context) => {
    const _pull = await ensureGetPulls(pull, octokit, context);
    return {
        ...context,
        actionContext: Object.assign({}, context.actionContext, {
            payload: {
                number: _pull.number,
                'pull_request': {
                    number: _pull.number,
                    id: _pull.id,
                    head: _pull.head,
                    base: _pull.base,
                    title: _pull.title,
                    'html_url': _pull.html_url,
                },
            },
            repo: {
                owner: _pull.base.repo.owner.login,
                repo: _pull.base.repo.name,
            },
            ref: `refs/heads/${_pull.head.ref}`,
        }),
        isBatchProcess: !!_pull.number,
    };
};
const getCacheKey = (method, args = {}) => method + JSON.stringify(args);
const getCache = async (key, generator, context) => {
    if (!(key in context.cache)) {
        // eslint-disable-next-line require-atomic-updates
        context.cache[key] = await generator();
    }
    return context.cache[key];
};
const isSetApiToken = () => !!getInput('API_TOKEN');
const getApiToken = () => getInput('API_TOKEN') || getAccessToken(true);
const isActiveTriggerWorkflow = (context) => isSetApiToken() && '' !== context.actionDetail.triggerWorkflowMessage;
const getTriggerWorkflowMessage = (context) => context.actionDetail.triggerWorkflowMessage ?? DEFAULT_TRIGGER_WORKFLOW_MESSAGE;
// eslint-disable-next-line no-magic-numbers
const getAutoMergeThresholdDays = (context) => context.actionDetail.autoMergeThresholdDays && /^\d+$/.test(context.actionDetail.autoMergeThresholdDays) ? Number(context.actionDetail.autoMergeThresholdDays) : -1;
const checkSuiteState = (checkSuiteId) => (suite) => {
    if (suite.conclusion === 'success') {
        return false;
    }
    if (suite.status !== 'in_progress' || suite.app.slug !== 'github-actions') {
        return true;
    }
    return suite.id !== checkSuiteId;
};
const isPassedAllChecks = async (octokit, context) => {
    const { data: status } = await octokit.rest.repos.getCombinedStatusForRef({
        ...context.actionContext.repo,
        ref: context.actionContext.sha,
    });
    if ('success' !== status.state) {
        return false;
    }
    const checkSuiteUrl = (await octokit.rest.actions.getWorkflowRun({
        ...context.actionContext.repo,
        'run_id': Number(process.env.GITHUB_RUN_ID),
    })).data['check_suite_url'];
    const checkSuiteId = Number(checkSuiteUrl.replace(/^.+\/(\d+)$/, '$1'));
    return !(await octokit.paginate(octokit.rest.checks.listSuitesForRef.endpoint.merge({
        ...context.actionContext.repo,
        ref: context.actionContext.sha,
    }))).filter(suite => checkSuiteState(checkSuiteId)(suite)).length;
};

const AllProcessResult = [
    'skipped',
    'not changed',
    'succeeded',
    'failed',
];

const { sleep, getBranch, objectGet } = Utils;
const { isPr, isPush } = ContextHelper;
const commonLogger = new Logger(replaceDirectory);
const getResult = (result, detail, context, fork) => ({
    result,
    detail,
    branch: (fork ? `${fork}:` : '') + (getPrHeadRef(context) || getBranch(context.actionContext)),
});
const checkActionPr = async (logger, octokit, context) => {
    const defaultBranch = await getDefaultBranch(octokit, context);
    if (defaultBranch === getPrHeadRef(context)) {
        return true;
    }
    const pr = await findPR(getPrHeadRef(context), octokit, context);
    if (!pr) {
        return getResult('failed', 'not found', context);
    }
    if (pr.base.ref === defaultBranch) {
        return true;
    }
    const basePr = await findPR(pr.base.ref, octokit, context);
    if (!basePr) {
        await closePR(getPrHeadRef(context), logger, context, '');
        return getResult('succeeded', 'has been closed because base PullRequest does not exist', context);
    }
    if (basePr.state === 'closed') {
        await closePR(getPrHeadRef(context), logger, context, '');
        return getResult('succeeded', 'has been closed because base PullRequest has been closed', context);
    }
    return true;
};
const autoMerge = async (pr, logger, octokit, context) => {
    const threshold = getAutoMergeThresholdDays(context);
    // eslint-disable-next-line no-magic-numbers
    if (threshold <= 0) {
        // disabled
        return false;
    }
    logger.startProcess('Checking auto merge...');
    const created = Date.parse(pr.created_at);
    const diff = Date.now() - created;
    // eslint-disable-next-line no-magic-numbers
    const days = Math.floor(diff / 86400000); // 1000 * 60 * 60 * 24
    if (days <= threshold) {
        // not more than threshold
        logger.info('Number of days since creation is not more than threshold.');
        logger.info('days: %d, threshold: %d', days, threshold);
        return false;
    }
    if (!await isMergeable(pr.number, octokit, context)) {
        // not mergeable
        logger.info('This PR is not mergeable.');
        return false;
    }
    if (!await isPassedAllChecks(octokit, context)) {
        // not passed all checked
        logger.info('This PR is not passed all checks.');
        return false;
    }
    logger.info('All checks are passed.');
    logger.startProcess('Auto merging...');
    try {
        await octokit.rest.pulls.merge({
            ...context.actionContext.repo,
            'pull_number': pr.number,
        });
    }
    catch (error) { // eslint-disable-line @typescript-eslint/no-explicit-any
        logger.warn(error.message);
        return false;
    }
    return true;
};
const createCommit = async (addComment, isClose, logger, octokit, context) => {
    const helper = getHelper(context);
    const branchName = await getPrBranchName(octokit, context);
    const { files, output, aborted } = await getChangedFiles(helper, logger, octokit, context);
    if (!files.length) {
        logger.info('There is no diff.');
        if (context.isBatchProcess) {
            const pr = await findPR(branchName, octokit, context);
            if (pr && !(await getRefDiff(getPrBaseRef(context), helper, logger, context)).length) {
                // Close if there is no diff
                await closePR(branchName, logger, context);
                return getResult('succeeded', 'has been closed because there is no reference diff', context);
            }
            if (pr && await autoMerge(pr, logger, octokit, context)) {
                return getResult('succeeded', 'has been auto merged', context);
            }
            if (pr && aborted) {
                // not mergeable
                logger.info('This PR is not mergeable.');
                // Resolve conflicts if PR is not mergeable
                return getResult('succeeded', await resolveConflicts(branchName, helper, logger, octokit, context), context);
            }
        }
        return getResult('not changed', 'There is no diff', context);
    }
    await commit(helper, logger, context);
    if (context.isBatchProcess) {
        if (!(await getRefDiff(getPrBaseRef(context), helper, logger, context)).length) {
            // Close if there is no diff
            await closePR(branchName, logger, context);
            return getResult('succeeded', 'has been closed because there is no reference diff', context);
        }
    }
    if (isClose) {
        return getResult('not changed', 'This is a close event', context);
    }
    await push(branchName, helper, logger, context);
    if (addComment) {
        await updatePr(branchName, files, output, helper, logger, octokit, context);
    }
    return getResult('succeeded', 'updated', context);
};
const noDiffProcess = async (branchName, isClose, logger, helper, octokit, context) => {
    logger.info('There is no diff.');
    const refDiffExists = !!(await getRefDiff(getPrHeadRef(context), helper, logger, context)).length;
    const pr = await findPR(branchName, octokit, context);
    if (!refDiffExists) {
        if (pr) {
            // Close if there is no ref diff
            await closePR(branchName, logger, context);
            return {
                mergeable: false,
                result: getResult('succeeded', 'has been closed because there is no reference diff', context),
            };
        }
        return {
            mergeable: false,
            result: getResult('not changed', 'There is no diff', context),
        };
    }
    if (isClose) {
        return {
            mergeable: false,
            result: getResult('not changed', 'This is a close event', context),
        };
    }
    if (!pr) {
        // There is no PR
        await updatePr(branchName, [], [], helper, logger, octokit, context);
        return {
            mergeable: false,
            result: getResult('succeeded', 'PullRequest created', context),
        };
    }
    return {
        mergeable: await isMergeable(pr.number, octokit, context),
    };
};
const diffProcess = async (files, output, branchName, isClose, logger, helper, octokit, context) => {
    // Commit local diffs
    await commit(helper, logger, context);
    if (!(await getRefDiff(getPrHeadRef(context), helper, logger, context)).length) {
        // Close if there is no diff
        await closePR(branchName, logger, context);
        return {
            mergeable: false,
            result: getResult('succeeded', 'has been closed because there is no reference diff', context),
        };
    }
    if (isClose) {
        return {
            mergeable: false,
            result: getResult('not changed', 'This is a close event', context),
        };
    }
    await push(branchName, helper, logger, context);
    return {
        mergeable: await updatePr(branchName, files, output, helper, logger, octokit, context),
    };
};
const createPr = async (makeGroup, isClose, helper, logger, octokit, context) => {
    if (makeGroup) {
        commonLogger.startProcess('Target PullRequest Ref [%s]', getPrHeadRef(context));
    }
    if (!isActionPr(context) && !await isTargetBranch(getPrHeadRef(context), octokit, context)) {
        return getResult('skipped', 'This is not a target branch', context);
    }
    if (isActionPr(context) || isNotCreatePR(context)) {
        const processResult = await checkActionPr(logger, octokit, context);
        if (processResult !== true) {
            return processResult;
        }
        return createCommit(isActionPr(context), isClose, logger, octokit, context);
    }
    const { files, output, aborted } = await getChangedFiles(helper, logger, octokit, context);
    const branchName = await getPrBranchName(octokit, context);
    let result = 'succeeded';
    let detail = 'updated';
    let mergeable = false;
    if (!files.length) {
        const processResult = await noDiffProcess(branchName, isClose, logger, helper, octokit, context);
        if (processResult.result) {
            return processResult.result;
        }
        mergeable = !aborted && processResult.mergeable;
        if (mergeable) {
            result = 'not changed';
            detail = 'There is no diff';
        }
    }
    else {
        const processResult = await diffProcess(files, output, branchName, isClose, logger, helper, octokit, context);
        if (processResult.result) {
            return processResult.result;
        }
        mergeable = processResult.mergeable;
    }
    if (!mergeable) {
        // Resolve conflicts if PR is not mergeable
        detail = await resolveConflicts(branchName, helper, logger, octokit, context);
    }
    return getResult(result, detail, context);
};
const outputResult = (result, endProcess = false) => {
    const mark = {
        'succeeded': commonLogger.c('✔', { color: 'green' }),
        'failed': commonLogger.c('×', { color: 'red' }),
        'skipped': commonLogger.c('→', { color: 'yellow' }),
        'not changed': commonLogger.c('✔', { color: 'yellow' }),
    };
    if (endProcess) {
        setOutput('result', result.result);
        commonLogger.endProcess();
    }
    commonLogger.info(mark[result.result] + '\t[%s] %s', result.branch, result.detail);
};
const getOutputResult = (results) => {
    const resultItems = results.map(result => result.result);
    // eslint-disable-next-line no-magic-numbers
    return AllProcessResult.filter(item => resultItems.includes(item)).slice(-1)[0] ?? AllProcessResult[0];
};
const outputResults = (results) => {
    const total = results.length;
    const succeeded = results.filter(item => item.result === 'succeeded').length;
    const failed = results.filter(item => item.result === 'failed').length;
    commonLogger.startProcess('Total:%d  Succeeded:%d  Failed:%d  Skipped:%d', total, succeeded, failed, total - succeeded - failed);
    results.forEach(result => outputResult(result));
    setOutput('result', getOutputResult(results));
};
const runCreatePr = async (isClose, getPulls, octokit, context) => {
    const logger = new Logger(replaceDirectory, true);
    const results = [];
    const processed = {};
    for await (const pull of getPulls(octokit, context)) {
        const actionContext = await getActionContext$1(pull, octokit, context);
        if (objectGet(pull.head.user, 'login') !== context.actionContext.repo.owner) {
            results.push(getResult('skipped', 'PR from fork', actionContext, objectGet(pull.head.user, 'login')));
            continue;
        }
        const helper = getHelper(actionContext);
        const isTarget = isActionPr(actionContext) || await isTargetBranch(getPrHeadRef(actionContext), octokit, actionContext);
        let target = '';
        if (isTarget) {
            target = await getPrBranchName(octokit, actionContext, true);
            if (target in processed) {
                results.push(getResult('skipped', `duplicated (${target})`, actionContext));
                continue;
            }
        }
        try {
            const result = await createPr(true, isClose, helper, logger, octokit, actionContext);
            if ('skipped' !== result.result) {
                processed[target] = true;
            }
            results.push(result);
        }
        catch (error) { // eslint-disable-line @typescript-eslint/no-explicit-any
            processed[target] = true;
            results.push(getResult('failed', error.message, actionContext));
        }
        await sleep(INTERVAL_MS);
    }
    await outputResults(results);
    const failed = results.filter(item => 'failed' === item.result).length;
    // eslint-disable-next-line no-magic-numbers
    if (1 === failed) {
        commonLogger.endProcess();
        throw new Error('There is a failed process.');
        // eslint-disable-next-line no-magic-numbers
    }
    else if (1 < failed) {
        commonLogger.endProcess();
        throw new Error('There are failed processes.');
    }
};
async function* getPulls(octokit, context) {
    const logger = new Logger(replaceDirectory, true);
    yield* await getApiHelper(octokit, context, logger).pullsList({});
    if (checkDefaultBranch(context)) {
        yield await getPullsArgsForDefaultBranch(octokit, context);
    }
}
const runCreatePrAll = async (octokit, context) => runCreatePr(false, getPulls, octokit, context);
const runCreatePrClosed = async (octokit, context) => runCreatePr(true, getPulls, octokit, context);
const execute = async (octokit, context) => {
    await branchConfig(getHelper(context), octokit, context);
    if (isClosePR(context)) {
        await runCreatePrClosed(octokit, context);
    }
    else if (isPush(context.actionContext)) {
        await outputResult(await createCommit(false, false, commonLogger, octokit, context), true);
    }
    else if (isPr(context.actionContext)) {
        await outputResult(await createPr(false, false, getHelper(context), commonLogger, octokit, context), true);
    }
    else {
        await runCreatePrAll(octokit, context);
    }
    commonLogger.endProcess();
};

const { showActionInfo } = ContextHelper;
const getLogger = (logger) => logger ?? new Logger();
/* istanbul ignore next */
const getContext = (option) => option.context ?? new Context();
const getActionContext = async (option) => ({
    actionContext: getContext(option),
    actionDetail: option,
    cache: {},
});
async function main(option) {
    if (option.rootDir) {
        showActionInfo(option.rootDir, getLogger(option.logger), getContext(option));
    }
    const octokit = Utils.getOctokit();
    if (!await isTargetContext(octokit, await getActionContext(option))) {
        getLogger(option.logger).info(option.notTargetEventMessage ?? 'This is not a target event.');
        return;
    }
    await execute(octokit, await getActionContext(option));
}
/* istanbul ignore next */
function run(option) {
    /* istanbul ignore next */
    main(option).catch(error => {
        console.log(error);
        setFailed(error.message);
    });
}

export { main, run };
