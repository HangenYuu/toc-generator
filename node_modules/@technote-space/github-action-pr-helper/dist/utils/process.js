"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.autoMerge = void 0;
const core_1 = require("@actions/core");
const github_action_helper_1 = require("@technote-space/github-action-helper");
const github_action_log_helper_1 = require("@technote-space/github-action-log-helper");
const command_1 = require("./command");
const misc_1 = require("./misc");
const variables_1 = require("./variables");
const constant_1 = require("../constant");
const types_1 = require("../types");
const { sleep, getBranch, objectGet } = github_action_helper_1.Utils;
const { isPr, isPush } = github_action_helper_1.ContextHelper;
const commonLogger = new github_action_log_helper_1.Logger(misc_1.replaceDirectory);
const getResult = (result, detail, context, fork) => ({
    result,
    detail,
    branch: (fork ? `${fork}:` : '') + ((0, misc_1.getPrHeadRef)(context) || getBranch(context.actionContext)),
});
const checkActionPr = (logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const defaultBranch = yield (0, command_1.getDefaultBranch)(octokit, context);
    if (defaultBranch === (0, misc_1.getPrHeadRef)(context)) {
        return true;
    }
    const pr = yield (0, command_1.findPR)((0, misc_1.getPrHeadRef)(context), octokit, context);
    if (!pr) {
        return getResult('failed', 'not found', context);
    }
    if (pr.base.ref === defaultBranch) {
        return true;
    }
    const basePr = yield (0, command_1.findPR)(pr.base.ref, octokit, context);
    if (!basePr) {
        yield (0, command_1.closePR)((0, misc_1.getPrHeadRef)(context), logger, context, '');
        return getResult('succeeded', 'has been closed because base PullRequest does not exist', context);
    }
    if (basePr.state === 'closed') {
        yield (0, command_1.closePR)((0, misc_1.getPrHeadRef)(context), logger, context, '');
        return getResult('succeeded', 'has been closed because base PullRequest has been closed', context);
    }
    return true;
});
const autoMerge = (pr, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const threshold = (0, misc_1.getAutoMergeThresholdDays)(context);
    // eslint-disable-next-line no-magic-numbers
    if (threshold <= 0) {
        // disabled
        return false;
    }
    logger.startProcess('Checking auto merge...');
    const created = Date.parse(pr.created_at);
    const diff = Date.now() - created;
    // eslint-disable-next-line no-magic-numbers
    const days = Math.floor(diff / 86400000); // 1000 * 60 * 60 * 24
    if (days <= threshold) {
        // not more than threshold
        logger.info('Number of days since creation is not more than threshold.');
        logger.info('days: %d, threshold: %d', days, threshold);
        return false;
    }
    if (!(yield (0, command_1.isMergeable)(pr.number, octokit, context))) {
        // not mergeable
        logger.info('This PR is not mergeable.');
        return false;
    }
    if (!(yield (0, misc_1.isPassedAllChecks)(octokit, context))) {
        // not passed all checked
        logger.info('This PR is not passed all checks.');
        return false;
    }
    logger.info('All checks are passed.');
    logger.startProcess('Auto merging...');
    try {
        yield octokit.rest.pulls.merge(Object.assign(Object.assign({}, context.actionContext.repo), { 'pull_number': pr.number }));
    }
    catch (error) { // eslint-disable-line @typescript-eslint/no-explicit-any
        logger.warn(error.message);
        return false;
    }
    return true;
});
exports.autoMerge = autoMerge;
const createCommit = (addComment, isClose, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    const helper = (0, misc_1.getHelper)(context);
    const branchName = yield (0, variables_1.getPrBranchName)(helper, octokit, context);
    const { files, output, aborted } = yield (0, command_1.getChangedFiles)(helper, logger, octokit, context);
    if (!files.length) {
        logger.info('There is no diff.');
        if (context.isBatchProcess) {
            const pr = yield (0, command_1.findPR)(branchName, octokit, context);
            if (pr && !(yield (0, command_1.getRefDiff)((0, misc_1.getPrBaseRef)(context), helper, logger, context)).length) {
                // Close if there is no diff
                yield (0, command_1.closePR)(branchName, logger, context);
                return getResult('succeeded', 'has been closed because there is no reference diff', context);
            }
            if (pr && (yield (0, exports.autoMerge)(pr, logger, octokit, context))) {
                return getResult('succeeded', 'has been auto merged', context);
            }
            if (pr && aborted) {
                // not mergeable
                logger.info('This PR is not mergeable.');
                // Resolve conflicts if PR is not mergeable
                return getResult('succeeded', yield (0, command_1.resolveConflicts)(branchName, helper, logger, octokit, context), context);
            }
        }
        return getResult('not changed', 'There is no diff', context);
    }
    yield (0, command_1.commit)(helper, logger, context);
    if (context.isBatchProcess) {
        if (!(yield (0, command_1.getRefDiff)((0, misc_1.getPrBaseRef)(context), helper, logger, context)).length) {
            // Close if there is no diff
            yield (0, command_1.closePR)(branchName, logger, context);
            return getResult('succeeded', 'has been closed because there is no reference diff', context);
        }
    }
    if (isClose) {
        return getResult('not changed', 'This is a close event', context);
    }
    yield (0, command_1.push)(branchName, helper, logger, context);
    if (addComment) {
        yield (0, command_1.updatePr)(branchName, files, output, helper, logger, octokit, context);
    }
    return getResult('succeeded', 'updated', context);
});
const noDiffProcess = (branchName, isClose, logger, helper, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    logger.info('There is no diff.');
    const refDiffExists = !!(yield (0, command_1.getRefDiff)((0, misc_1.getPrHeadRef)(context), helper, logger, context)).length;
    const pr = yield (0, command_1.findPR)(branchName, octokit, context);
    if (!refDiffExists) {
        if (pr) {
            // Close if there is no ref diff
            yield (0, command_1.closePR)(branchName, logger, context);
            return {
                mergeable: false,
                result: getResult('succeeded', 'has been closed because there is no reference diff', context),
            };
        }
        return {
            mergeable: false,
            result: getResult('not changed', 'There is no diff', context),
        };
    }
    if (isClose) {
        return {
            mergeable: false,
            result: getResult('not changed', 'This is a close event', context),
        };
    }
    if (!pr) {
        // There is no PR
        yield (0, command_1.updatePr)(branchName, [], [], helper, logger, octokit, context);
        return {
            mergeable: false,
            result: getResult('succeeded', 'PullRequest created', context),
        };
    }
    return {
        mergeable: yield (0, command_1.isMergeable)(pr.number, octokit, context),
    };
});
const diffProcess = (files, output, branchName, isClose, logger, helper, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    // Commit local diffs
    yield (0, command_1.commit)(helper, logger, context);
    if (!(yield (0, command_1.getRefDiff)((0, misc_1.getPrHeadRef)(context), helper, logger, context)).length) {
        // Close if there is no diff
        yield (0, command_1.closePR)(branchName, logger, context);
        return {
            mergeable: false,
            result: getResult('succeeded', 'has been closed because there is no reference diff', context),
        };
    }
    if (isClose) {
        return {
            mergeable: false,
            result: getResult('not changed', 'This is a close event', context),
        };
    }
    yield (0, command_1.push)(branchName, helper, logger, context);
    return {
        mergeable: yield (0, command_1.updatePr)(branchName, files, output, helper, logger, octokit, context),
    };
});
const createPr = (makeGroup, isClose, helper, logger, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    if (makeGroup) {
        commonLogger.startProcess('Target PullRequest Ref [%s]', (0, misc_1.getPrHeadRef)(context));
    }
    if (!(0, misc_1.isActionPr)(context) && !(yield (0, misc_1.isTargetBranch)((0, misc_1.getPrHeadRef)(context), octokit, context))) {
        return getResult('skipped', 'This is not a target branch', context);
    }
    if ((0, misc_1.isActionPr)(context) || (0, misc_1.isNotCreatePR)(context)) {
        const processResult = yield checkActionPr(logger, octokit, context);
        if (processResult !== true) {
            return processResult;
        }
        return createCommit((0, misc_1.isActionPr)(context), isClose, logger, octokit, context);
    }
    const { files, output, aborted } = yield (0, command_1.getChangedFiles)(helper, logger, octokit, context);
    const branchName = yield (0, variables_1.getPrBranchName)(helper, octokit, context);
    let result = 'succeeded';
    let detail = 'updated';
    let mergeable = false;
    if (!files.length) {
        const processResult = yield noDiffProcess(branchName, isClose, logger, helper, octokit, context);
        if (processResult.result) {
            return processResult.result;
        }
        mergeable = !aborted && processResult.mergeable;
        if (mergeable) {
            result = 'not changed';
            detail = 'There is no diff';
        }
    }
    else {
        const processResult = yield diffProcess(files, output, branchName, isClose, logger, helper, octokit, context);
        if (processResult.result) {
            return processResult.result;
        }
        mergeable = processResult.mergeable;
    }
    if (!mergeable) {
        // Resolve conflicts if PR is not mergeable
        detail = yield (0, command_1.resolveConflicts)(branchName, helper, logger, octokit, context);
    }
    return getResult(result, detail, context);
});
const outputResult = (result, endProcess = false) => {
    const mark = {
        'succeeded': commonLogger.c('✔', { color: 'green' }),
        'failed': commonLogger.c('×', { color: 'red' }),
        'skipped': commonLogger.c('→', { color: 'yellow' }),
        'not changed': commonLogger.c('✔', { color: 'yellow' }),
    };
    if (endProcess) {
        (0, core_1.setOutput)('result', result.result);
        commonLogger.endProcess();
    }
    commonLogger.info(mark[result.result] + '\t[%s] %s', result.branch, result.detail);
};
const getOutputResult = (results) => {
    var _a;
    const resultItems = results.map(result => result.result);
    // eslint-disable-next-line no-magic-numbers
    return (_a = types_1.AllProcessResult.filter(item => resultItems.includes(item)).slice(-1)[0]) !== null && _a !== void 0 ? _a : types_1.AllProcessResult[0];
};
const outputResults = (results) => {
    const total = results.length;
    const succeeded = results.filter(item => item.result === 'succeeded').length;
    const failed = results.filter(item => item.result === 'failed').length;
    commonLogger.startProcess('Total:%d  Succeeded:%d  Failed:%d  Skipped:%d', total, succeeded, failed, total - succeeded - failed);
    results.forEach(result => outputResult(result));
    (0, core_1.setOutput)('result', getOutputResult(results));
};
const runCreatePr = (isClose, getPulls, octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    var e_1, _a;
    const logger = new github_action_log_helper_1.Logger(misc_1.replaceDirectory, true);
    const results = [];
    const processed = {};
    try {
        for (var _b = __asyncValues(getPulls(octokit, context)), _c; _c = yield _b.next(), !_c.done;) {
            const pull = _c.value;
            const actionContext = yield (0, misc_1.getActionContext)(pull, octokit, context);
            if (objectGet(pull.head.user, 'login') !== context.actionContext.repo.owner) {
                results.push(getResult('skipped', 'PR from fork', actionContext, objectGet(pull.head.user, 'login')));
                continue;
            }
            const helper = (0, misc_1.getHelper)(actionContext);
            const isTarget = (0, misc_1.isActionPr)(actionContext) || (yield (0, misc_1.isTargetBranch)((0, misc_1.getPrHeadRef)(actionContext), octokit, actionContext));
            let target = '';
            if (isTarget) {
                target = yield (0, variables_1.getPrBranchName)(helper, octokit, actionContext, true);
                if (target in processed) {
                    results.push(getResult('skipped', `duplicated (${target})`, actionContext));
                    continue;
                }
            }
            try {
                const result = yield createPr(true, isClose, helper, logger, octokit, actionContext);
                if ('skipped' !== result.result) {
                    processed[target] = true;
                }
                results.push(result);
            }
            catch (error) { // eslint-disable-line @typescript-eslint/no-explicit-any
                processed[target] = true;
                results.push(getResult('failed', error.message, actionContext));
            }
            yield sleep(constant_1.INTERVAL_MS);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    yield outputResults(results);
    const failed = results.filter(item => 'failed' === item.result).length;
    // eslint-disable-next-line no-magic-numbers
    if (1 === failed) {
        commonLogger.endProcess();
        throw new Error('There is a failed process.');
        // eslint-disable-next-line no-magic-numbers
    }
    else if (1 < failed) {
        commonLogger.endProcess();
        throw new Error('There are failed processes.');
    }
});
/**
 * @param {Octokit} octokit octokit
 * @param {Context} context context
 * @return {AsyncIterable} pull
 */
function getPulls(octokit, context) {
    return __asyncGenerator(this, arguments, function* getPulls_1() {
        const logger = new github_action_log_helper_1.Logger(misc_1.replaceDirectory, true);
        yield __await(yield* __asyncDelegator(__asyncValues(yield __await((0, command_1.getApiHelper)(octokit, context, logger).pullsList({})))));
        if ((0, misc_1.checkDefaultBranch)(context)) {
            yield yield __await(yield __await((0, misc_1.getPullsArgsForDefaultBranch)(octokit, context)));
        }
    });
}
const runCreatePrAll = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () { return runCreatePr(false, getPulls, octokit, context); });
const runCreatePrClosed = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () { return runCreatePr(true, getPulls, octokit, context); });
const execute = (octokit, context) => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, command_1.branchConfig)((0, misc_1.getHelper)(context), octokit, context);
    if ((0, misc_1.isClosePR)(context)) {
        yield runCreatePrClosed(octokit, context);
    }
    else if (isPush(context.actionContext)) {
        yield outputResult(yield createCommit(false, false, commonLogger, octokit, context), true);
    }
    else if (isPr(context.actionContext)) {
        yield outputResult(yield createPr(false, false, (0, misc_1.getHelper)(context), commonLogger, octokit, context), true);
    }
    else {
        yield runCreatePrAll(octokit, context);
    }
    commonLogger.endProcess();
});
exports.execute = execute;
