import { getInput } from '@actions/core';
import { isTargetEvent, isTargetLabels } from '@technote-space/filter-github-action';
import { Utils, ContextHelper, GitHelper } from '@technote-space/github-action-helper';
import { Logger } from '@technote-space/github-action-log-helper';
import { DEFAULT_TARGET_EVENTS, DEFAULT_TRIGGER_WORKFLOW_MESSAGE } from '../constant';
import { getDefaultBranch } from './command';
const { getWorkspace, getPrefixRegExp, getAccessToken } = Utils;
const { escapeRegExp, replaceAll, getBranch } = Utils;
const { isPr, isCron, isPush, isCustomEvent, isManualEvent, isWorkflowRun } = ContextHelper;
export class ParameterRequiredError extends Error {
    constructor(target) {
        super(`parameter [${target}] is required.`);
        Object.setPrototypeOf(this, ParameterRequiredError.prototype);
    }
}
export const getActionDetail = (key, context, defaultValue) => {
    if (undefined === defaultValue && !(key in context.actionDetail)) {
        throw new ParameterRequiredError(key);
    }
    if (undefined === defaultValue && typeof context.actionDetail[key] === 'string' && context.actionDetail[key].trim() === '') {
        throw new ParameterRequiredError(key);
    }
    return context.actionDetail[key] || (typeof defaultValue === 'function' ? defaultValue() : undefined);
};
const toArray = (item) => Array.isArray(item) ? item : [item];
export const replaceDirectory = (message) => {
    const workDir = getWorkspace();
    return replaceAll(replaceAll(message, ` -C ${workDir}`, ''), workDir, '[Working Directory]');
};
export const getDefaultBranchUrl = async (octokit, context) => `https://github.com/${context.actionContext.repo.owner}/${context.actionContext.repo.repo}/tree/${await getDefaultBranch(octokit, context)}`;
export const getPrHeadRef = (context) => context.actionContext.payload.pull_request?.head.ref ?? '';
export const getPrBaseRef = (context) => context.actionContext.payload.pull_request?.base.ref ?? '';
export const getPrBranchPrefix = (context) => context.actionDetail.prBranchPrefix || `${context.actionDetail.actionRepo}/`;
export const getPrBranchPrefixForDefaultBranch = (context) => context.actionDetail.prBranchPrefixForDefaultBranch || getPrBranchPrefix(context);
export const isActionPr = (context) => getPrefixRegExp(getPrBranchPrefix(context)).test(getPrHeadRef(context)) || getPrefixRegExp(getPrBranchPrefixForDefaultBranch(context)).test(getPrHeadRef(context));
export const getContextBranch = (context) => context.isBatchProcess ? getPrBaseRef(context) : (getBranch(context.actionContext) || getPrHeadRef(context));
export const isDefaultBranch = async (octokit, context) => await getDefaultBranch(octokit, context) === getContextBranch(context);
export const checkDefaultBranch = (context) => context.actionDetail.checkDefaultBranch ?? true;
export const checkOnlyDefaultBranch = (context) => context.actionDetail.checkOnlyDefaultBranch ?? false;
export const isDisabledDeletePackage = (context) => !(context.actionDetail.deletePackage ?? false);
export const isClosePR = (context) => isPr(context.actionContext) && context.actionContext.payload.action === 'closed';
export const isNotCreatePR = (context) => true === context.actionDetail.notCreatePr;
export const isTargetBranch = async (branchName, octokit, context) => {
    if (branchName === await getDefaultBranch(octokit, context)) {
        return checkDefaultBranch(context);
    }
    const prefix = toArray(getActionDetail('targetBranchPrefix', context, () => []));
    if (prefix.length) {
        return prefix.some(prefix => getPrefixRegExp(prefix).test(branchName));
    }
    return !checkOnlyDefaultBranch(context);
};
export const isTargetContext = async (octokit, context) => {
    if (!isTargetEvent(context.actionDetail.targetEvents ?? DEFAULT_TARGET_EVENTS, context.actionContext)) {
        return false;
    }
    if (isCron(context.actionContext) || isCustomEvent(context.actionContext) || isManualEvent(context.actionContext) || isWorkflowRun(context.actionContext)) {
        return true;
    }
    if (isPush(context.actionContext)) {
        return isTargetBranch(getBranch(context.actionContext), octokit, context);
    }
    if (isActionPr(context)) {
        return true;
    }
    if (isClosePR(context)) {
        return true;
    }
    if (!await isTargetBranch(getPrHeadRef(context), octokit, context)) {
        return false;
    }
    return isTargetLabels(toArray(getActionDetail('includeLabels', context, () => [])), [], context.actionContext);
};
export const getGitFilterStatus = (context) => context.actionDetail.filterGitStatus;
export const filterGitStatus = (line, context) => {
    const filter = getGitFilterStatus(context);
    if (filter) {
        const targets = filter.toUpperCase().replace(/[^MDA]/g, '');
        if (!targets) {
            throw new Error('Invalid input [FILTER_GIT_STATUS].');
        }
        // language=JSRegexp
        return (new RegExp(`^[${targets}]\\s+`)).test(line);
    }
    return true;
};
export const filterExtension = (line, context) => {
    const extensions = toArray(getActionDetail('filterExtensions', context, () => []));
    if (extensions.length) {
        const pattern = '(' + extensions.map(item => escapeRegExp('.' + item.replace(/^\./, ''))).join('|') + ')';
        return (new RegExp(`${pattern}$`)).test(line);
    }
    return true;
};
export const getHelper = (context) => new GitHelper(new Logger(replaceDirectory), {
    depth: -1,
    filter: (line) => filterGitStatus(line, context) && filterExtension(line, context),
});
export const getPullsArgsForDefaultBranch = async (octokit, context) => ({
    number: 0,
    id: 0,
    head: {
        ref: await getDefaultBranch(octokit, context),
        user: {
            login: context.actionContext.repo.owner,
        },
    },
    base: {
        repo: {
            name: context.actionContext.repo.repo,
            owner: {
                login: context.actionContext.repo.owner,
            },
        },
        ref: await getDefaultBranch(octokit, context),
    },
    title: 'default branch',
    'html_url': await getDefaultBranchUrl(octokit, context),
});
export const ensureGetPulls = async (pull, octokit, context) => pull ?? await getPullsArgsForDefaultBranch(octokit, context);
export const getActionContext = async (pull, octokit, context) => {
    const _pull = await ensureGetPulls(pull, octokit, context);
    return {
        ...context,
        actionContext: Object.assign({}, context.actionContext, {
            payload: {
                number: _pull.number,
                'pull_request': {
                    number: _pull.number,
                    id: _pull.id,
                    head: _pull.head,
                    base: _pull.base,
                    title: _pull.title,
                    'html_url': _pull.html_url,
                },
            },
            repo: {
                owner: _pull.base.repo.owner.login,
                repo: _pull.base.repo.name,
            },
            ref: `refs/heads/${_pull.head.ref}`,
        }),
        isBatchProcess: !!_pull.number,
    };
};
export const getCacheKey = (method, args = {}) => method + JSON.stringify(args);
export const getCache = async (key, generator, context) => {
    if (!(key in context.cache)) {
        // eslint-disable-next-line require-atomic-updates
        context.cache[key] = await generator();
    }
    return context.cache[key];
};
export const isCached = (key, context) => key in context.cache;
export const isSetApiToken = () => !!getInput('API_TOKEN');
export const getApiToken = () => getInput('API_TOKEN') || getAccessToken(true);
export const isActiveTriggerWorkflow = (context) => isSetApiToken() && '' !== context.actionDetail.triggerWorkflowMessage;
export const getTriggerWorkflowMessage = (context) => context.actionDetail.triggerWorkflowMessage ?? DEFAULT_TRIGGER_WORKFLOW_MESSAGE;
// eslint-disable-next-line no-magic-numbers
export const getAutoMergeThresholdDays = (context) => context.actionDetail.autoMergeThresholdDays && /^\d+$/.test(context.actionDetail.autoMergeThresholdDays) ? Number(context.actionDetail.autoMergeThresholdDays) : -1;
export const checkSuiteState = (checkSuiteId) => (suite) => {
    if (suite.conclusion === 'success') {
        return false;
    }
    if (suite.status !== 'in_progress' || suite.app.slug !== 'github-actions') {
        return true;
    }
    return suite.id !== checkSuiteId;
};
export const isPassedAllChecks = async (octokit, context) => {
    const { data: status } = await octokit.rest.repos.getCombinedStatusForRef({
        ...context.actionContext.repo,
        ref: context.actionContext.sha,
    });
    if ('success' !== status.state) {
        return false;
    }
    const checkSuiteUrl = (await octokit.rest.actions.getWorkflowRun({
        ...context.actionContext.repo,
        'run_id': Number(process.env.GITHUB_RUN_ID),
    })).data['check_suite_url'];
    const checkSuiteId = Number(checkSuiteUrl.replace(/^.+\/(\d+)$/, '$1'));
    return !(await octokit.paginate(octokit.rest.checks.listSuitesForRef.endpoint.merge({
        ...context.actionContext.repo,
        ref: context.actionContext.sha,
    }))).filter(suite => checkSuiteState(checkSuiteId)(suite)).length;
};
